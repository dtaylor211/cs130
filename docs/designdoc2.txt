CS130 Project 2 - Design Document
=================================

Please answer all questions in this design document.  Note that the final
feedback section is optional, and you are not required to answer it if you
don't want to.

Unanswered or incompletely answered questions, or answers that don't actually
match the code/repository, will result in deductions.

Answers don't have to be deeply detailed!  We are mainly looking for an
overview or summary description of how your project works, and your team's
experiences working on this project.

Logistics (7 pts)
-----------------

L1.  [2pts] Enumerate all teammates here.

     Benjamin (Ben) Juarez, Kyle McGraw, Dallas Taylor

L2.  [2pts] What did each teammate focus on during this project?

     Ben:      Reordering/copying sheets, loading/saving workbooks
     Kyle:     Cell update notifications, renaming sheets
     Dallas:   Renaming sheets, profile visualization

L3.  [3pts] Approximately how many hours did each teammate spend on the project?

     Ben:      11
     Kyle:     11
     Dallas:   10


Spreadsheet Engine Design (10 pts)
----------------------------------

D1.  [3pts] Briefly describe how your workbook-loading code operates.  Does
     it do anything sophisticated to optimize the performance of loading a
     workbook, such as deferring cell-value update calculations, or analyzing
     the graph of cell dependencies?

     Our workbook-loading code is fairly straightforward.  For each component
     of the JSON file, as it's parsed we properly check/raise KeyErrors and 
     TypeErrors depending on if something is missing of if the type is improper.
     The core implementation relies on some of the methods we wrote last 
     project.  Specifically, for each sheet, we call new_sheet() to create the
     sheet.  For each sheet, we also iterate through the key/value pairs (
     location/contents pairs) and call set_cell_contents() for each of these 
     cells.  The logic for the appriopriate cell updating is handled in 
     set_cell_contents(), which eliminates any extra sophistication in 
     load_workbook() itself.  Thus, the new, loaded Workbook is returned. 

D2.  [3pts] Sheet-level operations like copying a sheet, deleting a sheet,
     renaming a sheet, or even creating a new sheet, can cause cell values
     to be updated.  How does your workbook identify such cells and ensure
     that they are updated properly?

     Our set_cell_contents() method handlings cell updating logic (by invoking
     update_cell_values()).  So, this is handled properly when copying a sheet
     since copy_sheet() calls set_cell_contents() for each copied cell. 
     For creating/deleting a new sheet, we call update_cell_values().  Also, 
     we added an optional argument to update_cell_values() which allows us to 
     pass in the renamed sheet name to this method.  Subsequently, this allows
     us to call update_cell_values() in rename_sheet() in order to handle cell
     updating for sheet renaming. 

D3.  [4pts] When renaming a sheet, cells with formulas that explicitly
     reference the renamed sheet must be updated with the new sheet name.
     Give an overview of how your implementation updates these formulas.

     As mentioned, our update_cell_values() method now has an optional parameter
     for the name of the renamed sheet.  If this parameter is present, then 
     the process for handling these references is initiated.  This is done by
     going through the cells that reference other cells on the renamed sheet.  
     For each cell we iterate through the adjacency list of the cell parents 
     graph.  This allows us to appropriately access each cell's contents and 
     re-set the contents with the new sheet name.  We also have a helper method
     format_sheet_names() which is invoked in this process which helps to handle
     the removal of single-quotes.


Spreadsheet Engine Code Review (17 pts)
---------------------------------------

R1.  [2pts] What part of your spreadsheet code-base did your team select to
     review?  Why did you select this portion of your code to review?

     We selected to review the formula evaluator implementation.  We selected
     this portion because we felt that it would be beneficial for all team 
     members to have a deeper understanding of this code as we move onto further
     projects.

R2.  [2pts] Approximately how much code did your team review?  How much time did
     the meeting take?

     We reviewed approx. 375 lines of code (mainly in evaluator.py).  This 
     meeting took approx. 30 minutes.

R3.  [6pts] Include the list of action-items that were generated by the
     code-review here.

     1)   Need to be prepared to switch to Interpreter implementation (instead of 
          Transformer)
     2)   Investigate the need for CELLREF token
     3)   Investigate need for expr target
     4)   Improve documentation, specifically regarding when/why errors are 
          thrown

R4.  [3pts] Have you been able to address the action items identified?  If not,
     what is your plan and timeframe to do so?

     Action item #4 was addressed during this project.  If time permits, action 
     items #2, #3 will be addressed before the project 2 deadline.  Action item 
     #1 will be addressed in the next project.

R5.  [4pts] Reflect on whether the code review helped with knowledge-sharing in
     the team.  Do teammates feel more confident maintaining the code that was
     reviewed, and/or extending the code in the future?

     We do believe that the code review was useful.  All teammates have a better
     understanding of our formula evaluator implementation now.  This will allow
     each teammate to have the capability maintain/extend this code in the 
     future.


Performance Analysis (16 pts)
-----------------------------

In this project you must measure and analyze the performance of two central
areas of your spreadsheet engine.  Using pair programming, construct some
performance tests to exercise these aspects of your engine, and use a profiler
to identify where your program is spending the bulk of its time.

A1.  [4pts] Briefly enumerate the performance tests you created to exercise
     your implementation, along with the teammates that collaborated to
     implement each of them.

     1 - test_circular_chain : Dallas and Kyle
          stress tests for very long circular chains/cycles
     2 - test_reference_chain : Dallas and Ben
          stress tests for very long reference chains
     3 - test_rename_volume1 : Dallas and Ben
          stress tests for renaming a sheet with a lot of references in another 
          sheet
     4 - test_rename_volume2 : Dallas, Ben, Kyle
          stress tests for renaming a sheet with a lot of cells in the sheet
          to be renamed
     5 - test_rename_chain : Dallas, Ben, Kyle
          stress tests for renaming a sheet that begins a long reference chain

A2.  [2pts] What profiler did you choose to run your performance tests with?
     Why?  Give an example of how to invoke one of your tests with the profiler.

     We used the cProfiler profiler since it is built-in and because there was 
     an useful amount of documentation accessible.  We also used SnakeViz (with
     permission) to better visualize how performance results.  The use of 
     SnakeViz has to be specificied by the user from the terminal. Upon running
     your desired performance test, the user will be prompted whether to 
     visualize the data, and further evaluation depends on their y/N response.
     
     Here is an example of how to invoke one of our tests with the profiler:

     (with $ make test_rename_volume2)
     python -m cProfile -o program.prof \
		./tests/performance/test_rename_volume2.py
	@read -p "Visualize Data? [y/N] " ans && ans=$${ans:-N} ; \
     if [ $${ans} = y ] || [ $${ans} = Y ]; then \
        snakeviz program.prof; \
     fi

     To run another performance test, you just hit another make target.

A3.  [6pts] What are ~3 of the most significant hot-spots you identified in your
     performance testing?  Did you expect these hot-spots, or were they
     surprising to you?

     We discovered one main hot spots, which was expected.
     1 - When renaming sheets, we spend a lot of time within the 
     update_cells call.  We expected this to be true because we suspect
     that we are unnecessarily calling update_cells too many times when we 
     rename a sheet.  This bug fix is under-way.

     We also discovered through the stress tests that we are reaching our
     maximum recursion depth at around ~900 nested reference cells.  We knew
     that we would run into this error, as our cell cycle detection is not 
     iterative yet.  This bug fix is also under-way.
     
A4.  [4pts] Reflect on the experience of pair-programming as you constructed
     these tests.  What went well with it?  What would you like to try to do
     better in the future?

     We had a really useful setup for our pair/tri-programming.  We were able 
     to AirPlay where the "driver" mirrors their display onto a TV while the 
     navigator(s) were able to sit comfortably together in a room.  It felt very
     efficient.  In the future, we can generally do a better job at speaking up
     when there is confusion (whether from the driver or the navigator(s)).

Section F:  CS130 Project 2 Feedback [OPTIONAL]
-----------------------------------------------

These questions are OPTIONAL, and you do not need to answer them.  Your grade
will not be affected by answering or not answering them.  Also, your grade will
not be affected by negative feedback - we want to know what went poorly so that
we can improve future versions of the course.

F1.  What parts of the assignment did you find highly enjoyable?  Conversely,
     what parts of the assignment did you find unenjoyable?


F2.  What parts of the assignment helped you learn more about software
     engineering best-practices, or other useful development skills?
     What parts were not helpful in learning these skills?


F3.  Were there any parts of the assignment that seemed _unnecessarily_ tedious?
     (Some parts of software development are always tedious, of course.)

     Handling the application/removal of single-quotes with sheet renaming felt
     a bit tedious.  Overall, this project felt significantly less tedious than
     the first.

F4.  Do you have any feedback and/or constructive criticism about how this
     project can be made better in future iterations of CS130?